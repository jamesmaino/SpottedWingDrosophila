---
title : Dispersal.jl example
author : Rafael Schouten
---

# Dispersal simulations
In this example we will run a simulation of the spread of the Spotted Winged

Drosophila _D. suzukii_ accross the continental USA.

### GTK window

Set up a simple rule that just copies the growthrate layer to a grid so that
we can view it next to the simulation.

```{julia; results=hidden}
tspan = DateTime(2020, 1), DateTime(2021, 1)
layercopy = Ruleset(LayerCopy(layer=growthrates_zeromissing))
init2 = (population=populationgrid, layer=layergrid)
multiruleset = MultiRuleset(
    rulesets=(
        population=dispersalruleset,
        layer=layercopy
    ),
    interactions=(),
    init=init2,
    mask=boolmask,
    timestep=timestep
);
```

Run the simulation in a DynamicGridsGtk window:

```{julia; results=hidden}
using DynamicGridsGtk
multiprocessor = LayoutProcessor([:population :layer], (algae, inferno))
output = GtkOutput(init2; ps=10, store=true, processor=multiprocessor,
                   minval=(zero(carrycap), minimum(growthrates_zeromissing)),
                   maxval=(carrycap, maximum(growthrates_zeromissing)))
output.running = false
output.fps = 6
display(output)
sim!(output, multiruleset; tspan=tspan);
```
And save it as a gif:

```{julia; results=hidden}
savegif(joinpath(basedir, "output/dispersal.gif"), output; fps=30)
```

Now with replicates:

```{julia; results=hidden}
#reps = 1:10 # simulation replicate
#initreps = [deepcopy(init) for i in 1:10]
#output = GtkOutput(init; ps=10, store=true, processor=jet, minval=0.0, maxval=carrycap)
#output.running = false
#output.fps = 300
#sim!(output, multiruleset; tspan=tspan, nreplicates=10);
```


### Interactive web outputs

```{julia; results=hidden}
# using DynamicGridsInteract
# output = InteractOutput(init, fallarmyworm;
                        # minval=minimum(0.0), maxval=carrycap, timestep=timestep,
                        # fps=10, store=true, processor=jet, slider_throttle=1.0)
# display(output)
# output.running = false
# sim!(output, fallarmyworm; tspan=tspan)
```


## Mapping incursion-point sensitivity

We will look at plotting some likely scenarios where incursion occurs
at a major port, then model all possible incursion scenarios.

Set up the simulation:

```{julia; results=hidden}
starttime = DateTime(2020, 1)
stoptime = DateTime(2021, 1)
tspan = starttime, stoptime
trange = starttime:timestep:stoptime
init = zero(populationgrid)
output = ArrayOutput(init, length(trange))
nreps = 10
```

Set up the output grid (which can be smaller than the sim to save time)
Now make some pathway plots for some key incursion points.

And generate the plot.

```{julia; results=hidden
function incursionplot(output, init, missingmask, key, (lat, lon), nreps, starttime, stoptime, timestep)
    println(key)
    len = length(starttime:timestep:stoptime)
    init .= 0
    init[Lat(Near(lat)), Lon(Near(lon))] = carrycap
    stepped = similar(output[1], Int)
    @set! stepped.refdims = ()
    @set! stepped.name = "Time at establishment (months)"
    stepped .= 0
    for rep in 1:nreps
        sim!(output, dispersalruleset; init=init, tspan=(starttime, stoptime))
        println("rep: ", rep)
        for f in eachindex(output)
            o = output[f]
            for j in size(stepped, 2), i in size(stepped, 1)
                val = stepped[i, j]
                if val == 0 && o[i, j] > 0
                    stepped[i, j] = val + len - f - 1
                end
            end
        end
    end
    plot(stepped ./ nreps .* missingmask; color=:inferno, xlabel="", ylabel="", title=key)
end
```

```{julia; results=hidden}
init = zero(populationgrid)
output = ArrayOutput(init, len)
plots = []
@profiler for (key, loc) in zip(keys(incursionpoints), incursionpoints)
    push!(plots, incursionplot(output, init, missingmask, key, loc, nreps, starttime, stoptime, timestep))
end
```

```{julia; results=hidden}
plot(plots...; size=(1000, 600))
savefig("output/incursionpathways.png")
```

We can also save the plots as individual figures.

```{julia; results=hidden}
for (i, key) in enumerate(keys(incursionpoints))
    plot(plots[i])
    savefig("output/incursionpathway_$key.png")
end
```


Now loop over all locations and reps to create grid where the value of each cell
reflects the mean number of cells invaded for an incursion commenced at that cell.


```{julia; results=hidden}
nreps = 10 #
scale = 50 # 3
cellsinvaded6 = GeoData.aggregate(populationgrid, scale=scale)
@set! cellsinvaded6.name = "Cells invaded"
cellsinvaded12 = deepcopy(cellsinvaded6)
init = deepcopy(populationgrid)
```

Then loop over the aggregated grid:

```{julia; results=hidden}
for i = 1:scale:size(cellsinvaded, 1) * scale,
    j = 1:scale:size(cellsinvaded, 2) * scale
    if boolmask[i, j]
        println(i,", ", j)
        init .= 0
        init[i, j] = carrycap
        invaded6 = 0
        invaded12 = 0
        for k in 1:nreps
            sim!(output, dispersalruleset; init=init, tspan=tspan)
            invaded6 += count(x -> x > zero(x), output[7])
            invaded12 += count(x -> zero(x), output[13])
        end
        cellsinvaded6[(i - 1) ÷ scale + 1, (j - 1) ÷ scale + 1] = invaded / nreps
        cellsinvaded12[(i - 1) ÷ scale + 1, (j - 1) ÷ scale + 1] = invaded / nreps
    end
end
```

Now plot:

```{julia; results=hidden}
area = cellsinvaded .* 9*9*1e-6 .*  aggregate(missingmask, scale=scale)
plot(area; colorbar_title="Area invaded from incursion pt. (million km²)", title="Area invaded after 12 months")
```

And save the output:

```{julia; results=hidden}
savefig("output/cellsinvaded$(nreps)reps.png")
write("output/cellsinvaded_6months_$(nreps)reps.tif", NCDarray, cellsinvaded6)
write("output/cellsinvaded_12months_$(nreps)reps.tif", NCDarray, cellsinvaded12)
```
