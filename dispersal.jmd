---
title : Dispersal.jl example
author : Rafael Schouten
---

# Dispersal simulations

In this example we will run a simulation of the spread of the Spotted Winged
Drosophila _D. suzukii_ accross the continental USA.

## Setup

First, load the required packages. Dates is a core julia package that
give us date/time handling, GeoData simplifies the loading of geospatial
raster files. It requires also loading NCDatasets.jl and ArchGDAL.jl to load
NetCDF and GeoTiff files, respectively.

```{julia; results=hidden}
# using Pkg
# Pkg.add(PackageSpec(url="https://github.com/rafaqz/GeoData.jl", rev="master"))
using GeoData, DimensionalData
using GeoData: Time
using DimensionalData: setdim, rebuild
using Dispersal, Dates, NCDatasets, ArchGDAL, Plots
basedir = ""
```

### Define simulation settings

We use DateTime units of for the timestep:

```{julia; results=hidden}
timestep = Month(1);
tspan = DateTime(2016, 1), DateTime(2020, 12)
nframes = length(tspan[1]:timestep:tspan[2])
aust = Lon(DimensionalData.Between(113.338953078, 153.569469029)),
       Lat(DimensionalData.Between(-43.6345972634, -10.6681857235))
```

---

## Define a RuleSet

This will involve combining multiple dispersal componenents into a single
`RuleSet` object: population growth, local dispersal, Allee effects, and human
dispersal.


### Climate driven population growth

Follow the [examples tutorial](https://rafaqz.github.io/GrowthRates.jl/dev/example/index.html) over
at [GrowthRates.jl](https://github.com/rafaqz/GrowthRates.jl). To skip this step
just download the output saved in the example:

```{julia; eval=false}
dataurl = "https://media.githubusercontent.com/media/cesaraustralia/Dispersal.jl/data"
growthratesfilename = "growthrates.ncd"
growthratesfilepath = joinpath(basedir, growthratesfilename)
isfile(growthratesfilepath) || download(joinpath(dataurl, growthratesfilename), joinpath(basedir, growthratesfilename))
```

And select just the bounding box for Australia, set the dimension order to Lat/Lon
and reverse the Lat dim:

```{julia; eval=false}
growthrates = NCDarray(growthratesfilepath)[aust...] |>
    x->permutedims(x, (Lat, Lon, GeoData.Time)) |>
    x->reverse(x; dims=Lat) |>
    x->setdim(x, rebuild(dims(x, GeoData.Time); grid=RegularGrid(; step=timestep)))
```

### Define a masking layer

This layer lets the simulation know which cells should be ignored.

```{julia; results=hidden}
masklayer = GeoData.boolmask(growthrates[GeoData.Time(1)])
plot(masklayer)
```

# Remove missing values from the array

```{julia; results=hidden}
growthrates = replace_missing(growthrates, 0.0)
```

Plot the growth layer:

```{julia; results=hidden}
using Plots, Statistics
plot(growthrates[GeoData.Time(1:2:12)]; legend=:none, clims=(0.0, 0.2))
plot(mean(growthrates[GeoData.Time(5:10)]; dims=GeoData.Time); legend=:none, clims=(0.0, 0.2))
```

Create a `ExactLogisticGrowthMap` rule from the layer, here we use
unitful units for the layers' `Time` dimension:

```{julia; results=hidden}
carrycap = 1e7
growth = ExactLogisticGrowthMap(layer=growthrates, carrycap=carrycap);
```

### Local dispersal

```{julia; results=hidden}
λ = 3.0
radius = 8
sze = 2radius + 1
dm = AreaToArea(30)
@time hood = DispersalKernel{radius}(;kernel=zeros(Float64, radius, radius),
                               formulation=ExponentialKernel(λ), distancemethod=dm)
localdisp = InwardsPopulationDispersal(hood);
```

### Allee effects

```{julia; results=hidden}
allee = AlleeExtinction(minfounders=200.0);
```

### Define initialisation data

Make a zeros array and populate the starting cells. We need to replace the `missing`
values with something else Dispersal.jl init can't contain `missing` or it will spread everywhere:

```{julia; results=hidden}
init = zero(replace_missing(growthrates[GeoData.Time(1)], NaN))

incursion = [(-27, 153)]

# Using `Near` finds the nearest cell to the coordinates
for (lat, lon) in incursion
    init[Lat(Near(lat)), Lon(Near(lon))] = carrycap
end
```

### Define a combined ruleset

```{julia; results=hidden}
ruleset = Ruleset(localdisp, allee, growth;
                  init=init,
                  mask=masklayer,
                  timestep=timestep);
```

---

## Output

The simplest and most performant output for a simulation is an ArrayOutput,
which simply writes the simulation to a preallocated array without visualising
it.

```{julia; results=hidden}
output = ArrayOutput(init, nframes)
```

### Run a simulation

To run a simulation, we pass in the output and rulset.

```{julia; results=hidden}
sim!(output, ruleset; tspan=tspan)
```

### Save a gif of your simulation

Gif files are an easy way to share the visual dynamics of the simulation. First
we need to define a color processor to turn the simulation into images for the
frames of the the gif. This processor can also be used later in web or gtk
outputs.

You can use the built-in `Greyscale` scheme, or any scheme from
[ColorSchemes.jl](https://github.com/JuliaGraphics/ColorSchemes.jl).

```{julia; results=hidden}
using ColorSchemes, Colors
zerocolor = RGB24(0.7)
maskcolor = RGB24(0.0)

oranges = ColorProcessor(ColorSchemes.Oranges_3, zerocolor, maskcolor)
jet = ColorProcessor(ColorSchemes.jet, zerocolor, maskcolor)
viridis = ColorProcessor(ColorSchemes.viridis, zerocolor, maskcolor)
```

With a non-image output like ArrayOuput we need to pass in the image processor
manually.

```{julia; results=hidden}
savegif(joinpath(basedir, "sim.gif"), output;
        minval=0.0, maxval=1e7, processor=oranges, fps=10)
```

### GTK window

```{julia; eval=false}
using DynamicGridsGtk
tspan = DateTime(2016, 1), DateTime(2054, 12)
output = GtkOutput(init; fps=10, store=true, processor=jet,
                   minval=minimum(growthrates), maxval=maximum(growthrates))
layercopy = Ruleset(LayerCopy(layer=growthrates); timestep=timestep, init=init, mask=masklayer)
sim!(output, layercopy; tspan=tspan)

output = GtkOutput(init; fps=10, store=true, processor=viridis,
                   minval=minimum(0.0), maxval=carrycap)
fallarmyworm = Ruleset(localdisp, allee, growth; timestep=timestep, init=init, mask=masklayer)
sim!(output, fallarmyworm; tspan=tspan)

init2 = (sim=init, layer=init)
multiprocessor = LayoutProcessor([:sim :layer], (viridis, jet))
output = GtkOutput(init2; fps=10, store=true, processor=multiprocessor,
                   minval=(0.0, minimum(growthrates)), maxval=(carrycap, maximum(growthrates)))
output.running = false
output.fps = 12

multiruleset = MultiRuleset(rulesets=(sim=fallarmyworm , layer=layercopy),
                       interactions=(),
                       init=init2,
                       mask=masklayer,
                       timestep=timestep)
sim!(output, multiruleset; tspan=tspan)
```


### Interactive web outputs

```{julia; eval=false}
using DynamicGridsInteract
output = InteractOutput(init, fallarmyworm;
                        minval=minimum(0.0), maxval=carrycap, timestep=timestep,
                        fps=10, store=true, processor=jet, slider_throttle=1.0)
display(output)
output.running = false
sim!(output, fallarmyworm; tspan=tspan)
```
