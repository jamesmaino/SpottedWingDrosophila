
```julia; results=hidden
using DataFrames, CSV
```

Now that we handle human dispersal in an interaction, we need to
define a new dispersl ruleset that handles just local dispersal modes.

```julia; results=hidden
# localdispersalruleset = Ruleset(
#     localdisp, allee, growth;
#     init=populationgrid,
#     mask=boolmask,
#     timestep=timestep,
# );
```
Setup the detection mechanism. Here we make it probabilistic, meaning detections occur at some rate for a given population and trap coverage. Then we define the detection model, generating a
random distribution of traps in cells containing crops of value.

```julia; results=hidden
# cropvalue is defined in impacts.jmd
# meantraps = 0.3
# trap_coverage = 0.1
# detection_rate = 0.1
# detectionmode = ProbabilisticDetectionMode(detection_rate, trap_coverage)
# detection = Biosecurity.MaskedDetection(;
#    population=:population,
#    detected=:detected,
#    sites=nothing,
#    sitemask=cropmask,
#    meantraps=meantraps,
#    detectionmode=detectionmode,
# )
```

Set the local and juristiction quarantine responses:

```julia; results=hidden
# response_radius =1
# neighborhood = RadialNeighborhood{response_radius}()
# locresponse = NeighborhoodResponse(;
#    controlgrid=:detected,
#    targetgrid=:loc,
#    neighborhood=neighborhood
# )
# juristictionresponse = RegionResponse(;
#    controlgrid=:detected,
#    targetgrid=:juristiction,
#    regions=states
# )
```

Now we can define the initial conditions grids.

```julia; results=hidden
# manageinit = (
#    population=populationgrid,
#    detected=detectedgrid,
#    loc=locgrid,
#    cost=costgrid,
# )
```

And define our ruleset:

```{julia; results=hidden}
# detectionruleset = Ruleset(
#    dispersalruleset.rules..., detection, locresponse, juristictionresponse;
#    init=manageinit,
#    mask=data(boolmask),
#    timestep=timestep,
# )
```

We use GtkOuput to run the simulation.

```{julia; results=hidden}
# using DynamicGridsGtk
# tspan = DateTime(2020, 1), DateTime(2030, 12)
# manageprocessor = LayoutProcessor([:population :detected], (viridis, jet, rainbow1, blues))
# output = GtkOutput(manageinit;
#    fps=100,
#    store=true,
#    processor=manageprocessor,
#    minval=(minimum(growthrates_zeromissing), nothing, nothing, nothing),
#    maxval=(1e6, nothing, nothing, nothing),
# )
# sim!(output, detectionruleset; tspan=tspan)
```

Now add an eradication model:

```{julia; results=hidden}
# eradication = Map{Tuple{:traps,:detected,:population},:population}() do traps, detected, population
#     if detected && traps > 0
#        min(population, (1-eradication_effect) * carrycap)
#     else
#        population
#     end
# end
# eradicationruleset = Ruleset(
#    dispersalruleset.rules..., detection, locresponse, juristictionresponse, eradication;
#    init=manageinit,
#    mask=boolmask,
#    timestep=timestep,
# )
```

And re-run the simulation with eradication in local quarantine areas:

```{julia; results=hidden}
# output = GtkOutput(manageinit;
#    fps=100,
#    store=true,
#    processor=manageprocessor,
#    minval=(zero(carrycap), nothing),
#    maxval=(carrycap, nothing),
# )
# sim!(output, eradicationruleset; tspan=tspan)
```


Now setup up a sensitivity analysis testing impacts of various management responses.

```{julia; results=hidden}
function build_fullruleset(eradication_effect, local_effect, trap_density, trap_radius, reporting_threshold)
   detection_rate = 0.0041
   trap_coverage = 0.1
   trap_operation_cost = 1000.0
   juristiction_scalar = 0.5
   croploss_fraction = 0.1
   eradication_costperkm = 1000u"km^-2"
   cell_mean_traps = trap_density * cellkms

   trapmode = ProbabilisticDetectionMode(detection_rate, trap_coverage)
   trap_detection = Biosecurity.TrapDetection(;
      traps=:traps,
      detected=:detected,
      population=:population,
      detectionmode=trapmode,
   )
   thresholdmode = ThresholdDetectionMode(reporting_threshold)
   late_detection = Biosecurity.Detection(;
      detected=:detected,
      population=:population,
      detectionmode=thresholdmode,
   )
   settraps = Biosecurity.SetTraps(;
      detectedgrid=:detected,
      trapgrid=:traps,
      neighborhood=RadialNeighborhood{trap_radius}(),
      meantraps=cell_mean_traps,
   )
   # Human disp is set up in spread.jmd
   quarantined_human_dispersal = QuarantinedHumanDispersal(;
      population=:population,
      local_quarantine=:detected,
      region_quarantine=:traps, # Hack - this is commented out in Bosecurity.jl
      rule=humandisp,
      local_effect=local_effect,
      region_effect=0.0,
   )
   eradication = let (ee, cc) = (eradication_effect, carrycap)
      Map{Tuple{:population,:detected,:traps},:population}() do population, detected, traps
          if detected == oneunit(detected) && traps > zero(traps)
             min(population, (oneunit(ee) - ee) * cc)
          else
             population
          end
      end
   end

   # Costs
   trap_cost = Map{Tuple{:traps,:cost},:cost}() do traps, cost
       if traps > 0
          cost + traps * trap_operation_cost / 12
       else
          cost
       end
   end
   croploss_cost = DynamicThresholdCost(;
       inputgrid=:population,
       costgrid=:cost,
       cellvalue=cropvalue,
       scalar=croploss_fraction / 12, # Scale from years to months
       threshold=1.0,
   )
   eradication_cost = DynamicCost(;
       inputgrid=:detected,
       costgrid=:cost,
       cellvalue=1.0,
       scalar=cellkms * eradication_costperkm * eradication_effect / 12,
   )
   local_quarantine_cost = DynamicCost(;
       inputgrid=:detected,
       costgrid=:cost,
       cellvalue=cropvalue,
       scalar=local_effect / 12, # Convert from years to months (the timestep)
   )

   # Ruleset
   Ruleset(
      localdisp, allee, growth,
      settraps,
      late_detection,
      trap_detection,
      eradication,
      quarantined_human_dispersal,
      croploss_cost, eradication_cost, local_quarantine_cost, trap_cost;

      init=fullinit,
      mask=boolmask,
      timestep=timestep,
      opt=SparseOpt(),
   )
end

randominit!(population, (lat, lon), growthmask) = begin
   population .= 0.0
   randomjump = 5
   i, j = DimensionalData.dims2indices(dims(populationgrid), (Lat(Contains(lat)), Lon(Contains(lon))))
   sze = size(population)
   i2, j2 = i, j
   for x in 1:100
      i2 = i + rand(0:randomjump)
      j2 = j + rand(0:randomjump)
      if i2 > 0 && i2 < sze[1] && j2 > 0 && j2 < sze[2] && growthmask[i2, j2]
         break
      end
   end
   println("attempted incursion: ", (i2, j2))
   population[i2, j2] = carrycap
   i2, j2
end
```

```{julia; results=hidden}
fullinit = (
   population=deepcopy(populationgrid),
   detected=deepcopy(detectedgrid),
   traps=deepcopy(trapgrid),
   cost=deepcopy(costgrid),
)
trapgrid
cellkms = (9u"km")^2
fullprocessor = LayoutProcessor(
   [:population :detected; :traps :cost],
   (viridis, jet, autumn, inferno)
)
```
Set up a Gtk output:

```{julia; results=hidden}
using DynamicGridsGtk
output = GtkOutput(fullinit;
   fps=100,
   store=true,
   processor=fullprocessor,
   minval=(zero(carrycap), nothing, -1, 0.0),
   maxval=(carrycap, nothing, 3, 1e6),
)
```

And run a simulation in it:

```{julia; results=hidden}
fullinit[:cost] .= 0
randominit!(fullinit[:population], incursionpoints[:Melbourne], growthmask)
init_trapgrid!(fullinit[:traps], incursionpoints)
tspan = DateTime(2020, 1), DateTime(2023, 1)
trange = tspan[1]:timestep:tspan[2]
nframes = length(trange)

trap_density        = 1e-2u"km^-2"
trap_radius         = 2
local_effect        = 0.5
eradication_effect  = 0.5
reporting_threshold  = carrycap / 2

# output = ArrayOutput(fullinit, nframes)
fullruleset = build_fullruleset(eradication_effect, local_effect, trap_density, trap_radius, reporting_threshold)
output.running = false
@time sim!(output, fullruleset; tspan=tspan);
```

Save a gif:
```{julia; results=hidden}
savegif("management_sim_low.gif", output, fullruleset; fps=6, )
```

Run replicates:

```{julia; results=hidden}
# Run for 3 years!!!!
tspan = DateTime(2020, 1), DateTime(2023, 1)
trange = tspan[1]:timestep:tspan[2]
nframes = length(trange)
trapmask = growthmask

eradication_effects         = [0.0, 0.5, 0.99, 0.9999, 0.999999]
local_quarantine_effects    = [0.0, 0.5, 0.99, 0.9999]
trap_densities              = [0.0, 0.0001, 0.001, 0.01, 0.1, 1.0] .* u"km^-2"
trap_radii                  = [1, 5, 10]

# eradication_effects         = [0.0, 0.9999]
# local_quarantine_effects    = [0.0, 0.9999]
# trap_radii                  = [1, 10]

nreps = 1 #30

trap_operation_cost = 1000.0
croploss_fraction = 0.1
croploss_threshold = 1.0
eradication_costperkm = 1e4u"km^-2"

sensitivity = [DataFrame(
   incursion = Symbol[],
   eradication = Float64[],
   local_quarantine = Float64[],
   trap_density =  Float64[],
   trap_radii =  Int[],
   replicate = Int[],
   timestep = Int[],
   area = Float64[],
   c_traps = Float64[],
   c_eradication = Float64[],
   c_quarantine = Float64[],
   c_industry = Float64[],
) for thread in 1:Threads.nthreads()]

#loc, point = :Melbourne, incursionpoints[:Melbourne]

@time for (loc, point) in zip(keys(incursionpoints), incursionpoints),
    e in eradication_effects,
    l in local_quarantine_effects,
    t in trap_densities,
    r in trap_radii
   println("running: ", (incursion=loc, eradication=e, loc_quarantine=l, trap_radius=r, trap_density=t, nreps=nreps))
   Threads.@threads for rep in 1:nreps
      # Initialise
      randominit!(fullinit[:population], point, growthmask)
      init_trapgrid!(fullinit[:traps], incursionpoints)
      fullinit[:cost] .= 0.0
      output = ArrayOutput(fullinit, nframes)

      ruleset = build_fullruleset(e, l, t, r, reporting_threshold)
      sim!(output, ruleset; tspan=tspan)
      for f in 1:length(output)
         area = count(x -> x > 0.0, output[f][:population]) * cellkms / u"km^2"
         c_traps = sum((output[f][:traps] .> 0) .* output[f][:traps] .* trap_operation_cost / 12)
         c_eradication = sum((output[f][:traps] .> 0) .* output[f][:detected] .* eradication_costperkm .* cellkms .* e ./ 12)
         c_quarantine = sum(output[f][:detected] .* cropvalue .* l ./ 12)
         c_industry = sum((output[f][:population] .>= 1) .* cropvalue ./ 12 .* croploss_fraction)
         push!(sensitivity[Threads.threadid()], (loc, e, l, t*u"km^2", r, rep, f, area, c_traps, c_eradication, c_quarantine, c_industry))
      end
   end
   yield()
end
CSV.write("output/sensitivity.csv", vcat(sensitivity...))
```

Plot using facets in R

```{julia; results=hidden}
using RCall
R"""
library(ggplot2)
library(dplyr)
library(magrittr)
"""

R"""
for (i in incursions)
   output %>%
   filter(incursion==i)
   group_by(eradication, local_quarantine, juristiction_quarantine, trap_density) %>%
   summarise(meanarea = mean(area),
                      meancost = mean(cost)) %>%
   ggplot(aes(trap_density, cost, color = eradication )) +
   geom_line() +
   facet_grid( local_quarantine ~ juristiction_quarantine )
   ggsave(paste0(i, ".png"))
end
"""
```

```{julia; results=hidden}
using DynamicGridsInteract
output = InteractOutput(fullinit, fullruleset;
   fps=100,
   store=true,
   processor=fullprocessor,
   minval=(minimum(growthrates_zeromissing), nothing, nothing, nothing, 0.0),
   maxval=(1e6, nothing, nothing, nothing, 1e8),
)
display(output.page)
output.running = false
sim!(output, fullruleset; tspan=tspan)
```
